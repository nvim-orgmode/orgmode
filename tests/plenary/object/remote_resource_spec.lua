local State = require('orgmode.state.state')
local config = require('orgmode.config')
local remote = require('orgmode.objects.remote_resource')

local config_backup = vim.deepcopy(config.opts)

describe('Remote resource', function()
  local SAFE_URL = 'https://example.com/'
  local UNSAFE_URL = 'http://bad.example.org/'

  after_each(function()
    config:extend(config_backup)
  end)

  describe('with policy "always"', function()
    before_each(function()
      config:extend({ org_resource_download_policy = 'always' })
    end)
    it('accepts everything', function()
      assert.is.True(remote.should_fetch(UNSAFE_URL):wait())
    end)
  end)

  describe('with policy "safe"', function()
    before_each(function()
      config:extend({
        org_resource_download_policy = 'safe',
        -- This implicitly tests that we use actual regexes and not Lua
        -- patterns (which would use `%` as escape character, not `\`).
        org_safe_remote_resources = { '^https://.*\\.com/\\?$' },
      })
    end)
    it('accepts safe URLs', function()
      assert.is.True(remote.should_fetch(SAFE_URL):wait())
    end)
    it('rejects unsafe URLs', function()
      assert.is.False(remote.should_fetch(UNSAFE_URL):wait())
    end)
  end)

  describe('with policy "prompt"', function()
    before_each(function()
      config:extend({ org_resource_download_policy = 'prompt' })
    end)
    it('opens a prompt', function()
      vim.api.nvim_input('<Esc>')
      assert.is.Nil(remote.should_fetch(SAFE_URL):wait())
    end)
    it('accepts on "y"', function()
      vim.api.nvim_input('y')
      assert.is.True(remote.should_fetch(SAFE_URL):wait())
    end)
    it('rejects on "n"', function()
      vim.api.nvim_input('n')
      assert.is.False(remote.should_fetch(SAFE_URL):wait())
    end)
    describe('and saving decisions', function()
      after_each(function()
        State:wipe()
      end)
      it('accepts forever with "!"', function()
        vim.api.nvim_input('!')
        assert.is.True(remote.should_fetch(SAFE_URL):wait())
        config:extend({ org_resource_download_policy = 'safe' })
        assert.is.True(remote.should_fetch(SAFE_URL):wait())
        assert.is.False(remote.should_fetch(SAFE_URL .. '/more'):wait())
        assert.is.False(remote.should_fetch(UNSAFE_URL):wait())
      end)
      it('accepts forever with "d"', function()
        vim.api.nvim_input('d')
        assert.is.True(remote.should_fetch(SAFE_URL):wait())
        config:extend({ org_resource_download_policy = 'safe' })
        assert.is.True(remote.should_fetch(SAFE_URL):wait())
        assert.is.True(remote.should_fetch(SAFE_URL .. '/more'):wait())
        assert.is.False(remote.should_fetch(UNSAFE_URL):wait())
      end)
      it('accepts forever with "f"', function()
        local todo_file = vim.fn.getcwd() .. '/tests/plenary/fixtures/todo.org'
        vim.cmd.edit(todo_file)
        vim.api.nvim_input('f')
        assert.is.True(remote.should_fetch(SAFE_URL):wait())
        config:extend({ org_resource_download_policy = 'safe' })
        assert.is.True(remote.should_fetch(SAFE_URL):wait())
        assert.is.True(remote.should_fetch(UNSAFE_URL):wait())
        vim.api.nvim_buf_set_name(0, '')
        assert.is.False(remote.should_fetch(SAFE_URL):wait())
      end)
    end)
  end)

  describe('with policy "never"', function()
    before_each(function()
      config:extend({ org_resource_download_policy = 'never' })
    end)
    it('rejects everything', function()
      assert.is.False(remote.should_fetch(SAFE_URL):wait())
    end)
  end)

  describe('default config', function()
    it('prompts', function()
      assert.are.equal('prompt', config.org_resource_download_policy)
    end)

    it('has no safe patterns', function()
      assert.are.same({}, config.org_safe_remote_resources)
    end)
  end)
end)
